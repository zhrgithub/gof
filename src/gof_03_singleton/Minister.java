package gof_03_singleton;

/**
 * 单例模式
 *
 * <p>优点： (1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了
 *
 * <p>(2)
 * 由于单例模式只生成一个实例，所以，减少系统的性能开销，当一个对象产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。
 *
 * <p>(3) 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作
 *
 * <p>(4) 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。
 *
 * <p>缺点： (1) 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。
 *
 * <p>(2) 单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context。
 *
 * <p>适用场景： 举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。
 * 也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。
 *
 * <p>继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，
 * 那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。
 *
 * <p>再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。
 * 但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制
 *
 * <p>同样，对于一些应用程序的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。
 * 从上述的例子中我们可以总结出适合使用单例模式的场景和优缺点： 适用场景： 1.需要生成唯一序列的环境
 *
 * <p>2.需要频繁实例化然后销毁的对象。
 *
 * <p>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
 *
 * <p>4.方便资源相互通信的环境
 */
@SuppressWarnings("all")
public class Minister {

  public static void main(String[] args) {
    Emperor emperor1 = Emperor.getInstance();
    emperor1.emperorInfo();

    Emperor emperor2 = Emperor.getInstance();
    emperor2.emperorInfo();

    Emperor emperor3 = Emperor.getInstance();
    emperor3.emperorInfo();
  }
}
